# -*- coding: utf-8 -*-
"""LatihanPengolahanCitra.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15SiLw3s4IIowUM8j29g9NOGCZSvZFu_D
"""

!pip install opencv-python

from google.colab import files
uploaded = files.upload()

import os
os.listdir()

from google.colab import drive
drive.mount('/content/drive')

import cv2
import matplotlib.pyplot as plt

image_path = "/content/drive/MyDrive/Colab Notebooks/Latihan-Kelas-PengolahanCitraDigital/pexels-simon-robben-55958-614810.jpg"
image = cv2.imread(image_path)
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

plt.imshow(image)
plt.axis('off')
plt.show()

# memanggil library opencv
import cv2

# memanggil fungsi google colab untuk perbaikan cv2.imshow
from google.colab.patches import cv2_imshow

# menyimpan gambar dengan fungsi imread dari OpenCV
# Ensure the path is correct and points to where the image was uploaded
# or is stored in your Google Drive
img = cv2.imread('/content/drive/MyDrive/Colab Notebooks/Latihan-Kelas-PengolahanCitraDigital/pexels-simon-robben-55958-614810.jpg')

# Check if the image was loaded correctly
if img is None:
  print("Error: Image not loaded. Check the file path.")
else:
  # menampilkan gambar dengan fungsi cv2_imshow
  cv2_imshow(img)

  # lihat tipe data img. disimpan sebagai apa?
  print(img.shape) #menampilkan resolusi
  print(img.size) #menampilkan ukuran data pada media penyimpan
  print(img.dtype) #image datatype (kedalaman bit)
  print(type(img))

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import drive
drive.mount('/content/drive')

#2. Mount Google Drive dan Load Gambar#
# Ganti dengan path gambar di Google Drive
image_path = "/content/drive/MyDrive/Colab Notebooks/Latihan-Kelas-PengolahanCitraDigital/pexels-simon-robben-55958-614810.jpg"
image = cv2.imread(image_path)
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  # BGR to RGB

#3. Ekstraksi BAND RGB#
# Pisahkan channel RGB
R, G, B = cv2.split(image)

# Tampilkan masing-masing band
fig, axs = plt.subplots(1, 4, figsize=(20, 5))

axs[0].imshow(image)
axs[0].set_title('Original Image')
axs[0].axis('off')

axs[1].imshow(R, cmap='Reds')
axs[1].set_title('Red Band')
axs[1].axis('off')

axs[2].imshow(G, cmap='Greens')
axs[2].set_title('Green Band')
axs[2].axis('off')

axs[3].imshow(B, cmap='Blues')
axs[3].set_title('Blue Band')
axs[3].axis('off')

plt.tight_layout()
plt.show()

#4. Menampilkan Band sebagai Gambar Penuh Warna (opsional)#
# Buat citra hanya dengan satu kanal, kanal lain di-set ke 0
zeros = np.zeros_like(R)

red_img = cv2.merge([R, zeros, zeros])
green_img = cv2.merge([zeros, G, zeros])
blue_img = cv2.merge([zeros, zeros, B])

# Tampilkan hasil
fig, axs = plt.subplots(1, 3, figsize=(15, 5))

axs[0].imshow(red_img)
axs[0].set_title('Red Channel')
axs[0].axis('off')

axs[1].imshow(green_img)
axs[1].set_title('Green Channel')
axs[1].axis('off')

axs[2].imshow(blue_img)
axs[2].set_title('Blue Channel')
axs[2].axis('off')

plt.show()

# memanggil modul yang diperlukan
import cv2
import numpy as np
from matplotlib import pyplot as plt
from google.colab.patches import cv2_imshow
from google.colab import drive

# Mount Google Drive to access the image
drive.mount('/content/drive')

#bgr
# Update the path to the correct location of your image in Google Drive
img = cv2.imread('/content/drive/MyDrive/Colab Notebooks/Latihan-Kelas-PengolahanCitraDigital/pexels-simon-robben-55958-614810.jpg')

# Check if the image was loaded correctly
if img is None:
  print("Error: Image not loaded. Check the file path.")
else:
  #rgb
  simon_robben = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

  # tampilkan gambar awal tanpa filter
  cv2_imshow(img)


  # membuat filter: matriks berukuran 5 x 5
  kernel = np.ones((5,5),np.float32)/25
  print(kernel)

  # lakukan filtering
  simon_robben_filter = cv2.filter2D(img,-1,kernel)

  cv2_imshow(simon_robben_filter)

# salt and pepper
  cv2_imshow(img)


  # membuat filter: matriks berukuran 5 x 5
  kernel = np.ones((5,5),np.float32)/25
  print(kernel)

  # lakukan filtering
  simon_robben_filter = cv2.filter2D(img,-1,kernel)

  cv2_imshow(simon_robben_filter)

# salt and pepper

# memanggil library yang dibutuhkan
import cv2
import numpy as np
from matplotlib import pyplot as plt

# jika file gambar.jpg yang digunakan, hilangkan tanda komentar
# Since 'img' was not defined before, let's use the previous image path
img = cv2.imread('/content/drive/MyDrive/Colab Notebooks/Latihan-Kelas-PengolahanCitraDigital/pexels-simon-robben-55958-614810.jpg')


color = ('b','g','r')
for i,col in enumerate(color):
  histr = cv2.calcHist([img],[i],None,[256],[0,256])
  plt.plot(histr,color = col)
  plt.xlim([0,256])
plt.show()

import cv2
import numpy as np
from matplotlib import pyplot as plt
from google.colab.patches import cv2_imshow # Import cv2_imshow


img = cv2.imread('/content/drive/MyDrive/Colab Notebooks/Latihan-Kelas-PengolahanCitraDigital/pexels-simon-robben-55958-614810.jpg')
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV);

# slider adalah salah satu fungsi Google Colab
# 3 dan 27 adalah batas warna orange pada band hue
# rubah slider untuk mencoba hasil akhir yang berbeda
batas_bawah = 5 #@param {type:"slider", min:0, max:360, step:1}
batas_atas = 72 #@param {type:"slider", min:0, max:360, step:1}

# definisi batas warna orange. perhatikan variabel batas_bawah dan batas_atas
lower_orange = np.array([batas_bawah,100,100])
upper_orange = np.array([batas_atas,255,255])

# membuat masking untuk mencari objek sesuai batas warna
mask = cv2.inRange(hsv, lower_orange, upper_orange)

# Operasi Bitwise-AND
res = cv2.bitwise_and(img, img, mask=mask)

# cetak hasil ke layar
print("gambar asal")
cv2_imshow(img); # cv2_imshow is now defined

print("masking warna")
cv2_imshow(mask)

print("hasil operasi")
cv2_imshow(res)

"""**Image Thresholding** adalah teknik dalam pengolahan citra digital untuk mengubah gambar berwarna atau grayscale menjadi gambar biner (hitam-putih) dengan cara membandingkan nilai intensitas pixel terhadap nilai ambang (threshold) tertentu.

üìå Contoh Kasus:

*   Deteksi tepi objek.
*   Segmentasi citra objek dan latar belakang.
*   Deteksi teks di gambar.

üìå Jenis Thresholding:

*   Global Thresholding
: Menggunakan satu nilai threshold untuk seluruh gambar.

*   Adaptive Thresholding
: Menggunakan nilai threshold yang berbeda-beda tergantung wilayah lokal gambar.

*   Otsu‚Äôs Method
: Menentukan nilai threshold optimal secara otomatis dengan meminimalkan variansi dalam antar kelas pixel.

üìå 1Ô∏è‚É£ Canny Edge Detection:
Algoritma Canny adalah salah satu metode deteksi tepi paling populer dan efektif, karena hasilnya halus dan minim noise.
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image - ensure the path is correct
img = cv2.imread('/content/drive/MyDrive/Colab Notebooks/Latihan-Kelas-PengolahanCitraDigital/pexels-simon-robben-55958-614810.jpg', 0) # Load as grayscale directly

# Check if the image was loaded correctly
if img is None:
  print("Error: Image not loaded. Check the file path.")
else:
  # deteksi tepi dengan Canny Edge
  edges = cv2.Canny(img,100,200)

  plt.subplot(121),plt.imshow(img,cmap = 'gray')
  plt.title('Original Image'), plt.xticks([]), plt.yticks([])
  plt.subplot(122),plt.imshow(edges,cmap = 'gray')
  plt.title('Edge Image'), plt.xticks([]), plt.yticks([])

  plt.show()

"""üìå 2Ô∏è‚É£ Sobel Operator:
Menggunakan dua kernel (horizontal dan vertikal) untuk mendeteksi tepi berdasarkan perubahan gradien intensitas pixel.
Biasanya dipakai untuk deteksi tepi arah tertentu (X, Y, atau keduanya).
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image - ensure the path is correct
img = cv2.imread('/content/drive/MyDrive/Colab Notebooks/Latihan-Kelas-PengolahanCitraDigital/pexels-simon-robben-55958-614810.jpg', 0) # Load as grayscale directly

# Check if the image was loaded correctly
if img is None:
  print("Error: Image not loaded. Check the file path.")
else:
  # Sobel X (horizontal edges)
  sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=3)

  # Sobel Y (vertical edges)
  sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=3)

  # Combine both directions
  sobel_combined = cv2.magnitude(sobelx, sobely)

  # Tampilkan hasil
  plt.figure(figsize=(12, 8))

  plt.subplot(2,2,1), plt.imshow(img, cmap='gray')
  plt.title('Original Image'), plt.xticks([]), plt.yticks([])

  plt.subplot(2,2,2), plt.imshow(sobelx, cmap='gray')
  plt.title('Sobel X'), plt.xticks([]), plt.yticks([])

  plt.subplot(2,2,3), plt.imshow(sobely, cmap='gray')
  plt.title('Sobel Y'), plt.xticks([]), plt.yticks([])

  plt.subplot(2,2,4), plt.imshow(sobel_combined, cmap='gray')
  plt.title('Combined Sobel (Magnitude)'), plt.xticks([]), plt.yticks([])

  plt.tight_layout()
  plt.show()

"""üìå 3Ô∏è‚É£ Prewitt Operator:
Mirip Sobel, tapi lebih sederhana.
Menghitung gradien intensitas pada arah X dan Y.
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
img = cv2.imread('/content/drive/MyDrive/Colab Notebooks/Latihan-Kelas-PengolahanCitraDigital/pexels-simon-robben-55958-614810.jpg', 0) # Load grayscale

# Check if the image was loaded correctly
if img is None:
  print("Error: Image not loaded. Check the file path.")
else:
  # Buat kernel Prewitt untuk X dan Y
  kernel_prewitt_x = np.array([[ -1, 0, 1],
                               [ -1, 0, 1],
                               [ -1, 0, 1]])

  kernel_prewitt_y = np.array([[ 1,  1,  1],
                               [ 0,  0,  0],
                               [-1, -1, -1]])

  # Apply filter Prewitt
  prewitt_x = cv2.filter2D(img, -1, kernel_prewitt_x)
  prewitt_y = cv2.filter2D(img, -1, kernel_prewitt_y)

  # Gabungkan hasil X dan Y
  prewitt_combined = cv2.addWeighted(prewitt_x, 0.5, prewitt_y, 0.5, 0)

  # Thresholding hasil Prewitt combined
  _, prewitt_thresh = cv2.threshold(prewitt_combined, 100, 255, cv2.THRESH_BINARY)

  # Tampilkan hasil
  plt.figure(figsize=(12,8))

  plt.subplot(2,2,1), plt.imshow(img, cmap='gray')
  plt.title('Original Image'), plt.xticks([]), plt.yticks([])

  plt.subplot(2,2,2), plt.imshow(prewitt_x, cmap='gray')
  plt.title('Prewitt X'), plt.xticks([]), plt.yticks([])

  plt.subplot(2,2,3), plt.imshow(prewitt_y, cmap='gray')
  plt.title('Prewitt Y'), plt.xticks([]), plt.yticks([])

  plt.subplot(2,2,4), plt.imshow(prewitt_thresh, cmap='gray')
  plt.title('Thresholded Prewitt'), plt.xticks([]), plt.yticks([])

  plt.tight_layout()
  plt.show()


# -Horizontal (X) ‚Üí mendeteksi tepi vertikal.
# -Vertikal (Y) ‚Üí mendeteksi tepi horizontal.
# -cv2.filter2D() ‚Üí menerapkan filter konvolusi custom.
# -cv2.addWeighted() ‚Üí menggabungkan hasil Prewitt X dan Y.
# -cv2.threshold() ‚Üí membuat hasil tepi jadi hitam-putih (binary) sesuai ambang (misal 100).

"""üìå 4Ô∏è‚É£ Roberts Cross:
Deteksi tepi dengan cara menghitung gradien secara diagonal.
Lebih cepat tapi sensitif terhadap noise.
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
img = cv2.imread('/content/drive/MyDrive/Colab Notebooks/Latihan-Kelas-PengolahanCitraDigital/pexels-simon-robben-55958-614810.jpg', 0)  # Load grayscale

# Check if the image was loaded correctly
if img is None:
  print("Error: Image not loaded. Check the file path.")
else:
  # Buat kernel Roberts Cross untuk X dan Y
  kernel_roberts_x = np.array([[1, 0],
                               [0, -1]], dtype=np.float32)

  kernel_roberts_y = np.array([[0, 1],
                               [-1, 0]], dtype=np.float32)

  # Apply filter Roberts
  roberts_x = cv2.filter2D(img, -1, kernel_roberts_x)
  roberts_y = cv2.filter2D(img, -1, kernel_roberts_y)

  # Gabungkan hasil X dan Y
  roberts_combined = cv2.addWeighted(roberts_x, 0.5, roberts_y, 0.5, 0)

  # Thresholding hasil Roberts combined
  _, roberts_thresh = cv2.threshold(roberts_combined, 30, 255, cv2.THRESH_BINARY)

  # Tampilkan hasil
  plt.figure(figsize=(12,8))

  plt.subplot(2,2,1), plt.imshow(img, cmap='gray')
  plt.title('Original Image'), plt.xticks([]), plt.yticks([])

  plt.subplot(2,2,2), plt.imshow(roberts_x, cmap='gray')
  plt.title('Roberts X'), plt.xticks([]), plt.yticks([])

  plt.subplot(2,2,3), plt.imshow(roberts_y, cmap='gray')
  plt.title('Roberts Y'), plt.xticks([]), plt.yticks([])

  plt.subplot(2,2,4), plt.imshow(roberts_thresh, cmap='gray')
  plt.title('Thresholded Roberts'), plt.xticks([]), plt.yticks([])

  plt.tight_layout()
  plt.show()

  # -Ukuran 2√ó2.
  # -Sangat cepat tapi sensitif terhadap noise.
  # -Detect tepi secara diagonal.
  # -cv2.filter2D() ‚Üí menerapkan kernel ke citra.
  # -cv2.addWeighted() ‚Üí menggabungkan hasil filter X dan Y.
  # -cv2.threshold() ‚Üí mengubah hasil jadi citra biner.